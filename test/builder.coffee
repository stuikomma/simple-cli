diff = require 'deep-diff'

describe 'builder', ->
  Given -> @async = {}
  Given -> @readline =
    createInterface: sinon.stub()
  Given -> @Builder = sandbox '../lib/builder',
    'win-spawn': {}
    readline: @readline
    async: @async

  describe 'constructor', ->
    Given -> @options =
      cmd: 'cmd'
      task: 'task'
      callback: 'foo'
      options: 'options'
    Given -> @context =
      options: sinon.stub()
      async: sinon.stub()
    Given -> @grunt =
      option: sinon.stub()
    Given -> @context.options.returns
      simple:
        debug: true
        env:
          HELLO: 'world'
      foo: 'bar'
    Given -> @context.async.returns 'async'

    context 'options.cmd', ->
      Given -> @env = process.env
      Given -> @env.HELLO = 'world'
      When -> @builder = new @Builder @options, @context, @grunt
      Then -> expect(@builder.cmd).to.equal 'cmd'
      And -> expect(@builder.done).to.equal 'foo'
      And -> expect(@builder.options).to.deep.equal foo: 'bar'
      And -> expect(@builder.config).to.deep.equal
        debug: true
        env:
          HELLO: 'world'
      And -> expect(@builder.debugOn).to.be.true()
      And -> expect(@builder.context).to.equal @context
      And -> expect(@builder.grunt).to.equal @grunt
      And -> expect(@builder.customOptions).to.equal 'options'
      And ->
        console.log(diff(@builder.env, @env))
        expect(@builder.env).to.deep.equal @env

    context 'options.task', ->
      Given -> delete @options.cmd
      When -> @builder = new @Builder @options, @context, @grunt
      Then -> expect(@builder.cmd).to.equal 'task'

    context 'no callback', ->
      Given -> delete @options.callback
      When -> @builder = new @Builder @options, @context, @grunt
      Then -> expect(@builder.done).to.equal 'async'

    context 'grunt.option', ->
      Given -> @grunt.option.withArgs('debug').returns 'grunt'
      When -> @builder = new @Builder @options, @context, @grunt
      Then -> expect(@builder.debugOn).to.equal 'grunt'

  describe '.configure', ->
    Given -> @context =
      context:
        target: 'bananaStand'
        data: {}
      config:
        cmd: 'foo'

    context 'cmd', ->
      When -> @builder = @Builder.prototype.configure.apply @context
      Then -> expect(@context.target).to.equal 'foo'
      And -> expect(@builder).to.equal @context

    context 'context.target', ->
      Given -> delete @context.config.cmd
      When -> @builder = @Builder.prototype.configure.apply @context
      Then -> expect(@context.target).to.equal 'banana-stand'

    context 'data is string', ->
      Given -> @context.context.data = 'git er done'
      When -> @builder = @Builder.prototype.configure.apply @context
      Then -> expect(@context.target).to.equal 'git'
      And -> expect(@context.config.cmd).to.equal 'git'
      And -> expect(@context.config.args).to.deep.equal ['er', 'done']

    context 'data is array', ->
      Given -> @context.context.data = ['git', 'er', 'done']
      When -> @builder = @Builder.prototype.configure.apply @context
      Then -> expect(@context.target).to.equal 'git'
      And -> expect(@context.config.cmd).to.equal 'git'
      And -> expect(@context.config.args).to.deep.equal ['er', 'done']

    context 'args is string', ->
      Given -> @context.config.args = 'git er done'
      When -> @builder = @Builder.prototype.configure.apply @context
      Then -> expect(@context.target).to.equal 'foo'
      And -> expect(@context.config.cmd).to.equal 'foo'
      And -> expect(@context.config.args).to.deep.equal ['git', 'er', 'done']

  describe '.buildOptions', ->
    Given -> @context =
      config:
        args: ['foo', 'bar']
        rawArgs: ['hello', 'world']
      options:
        a: true
        b: 'b'
        bool: true
        long: 'baz'
        'name=': 'Andrew'
    When -> @Builder.prototype.buildOptions.apply @context
    Then -> expect(@context.args).to.deep.equal [
      'foo', 'bar',
      '-a', '-b', 'b',
      '--bool', '--long', 'baz',
      '--name=Andrew',
      'hello', 'world'
    ]

  describe '.getDynamicValues', ->
    # There are ridiculous shenanigans involved in
    # stubbing console.log only SOMETIMES. But . . .
    # I really hate noise in test output, so
    # I'm doing it anyway.
    ###### Commense shenanigans #######
    afterEach -> console.log.restore()
    Given -> @log = console.log # Store a reference to log, so we can stub it but still call it
    Given -> @console = console # Need a reference to console, so we can apply it later
    # The rarely used 3-arg versoin of .stub, where the 3rd argument is the function
    # to call when the stub is invoked
    Given -> sinon.stub console, 'log', (a) =>
      # If this a log generated by the test itself, ignore it.
      # If it's generated by the test framework . . . these aren't thre droids we're looking for.
      if a and a.indexOf('Enter values for') == -1
        @log.apply @console, arguments
    ###### End shenanigans #######
    
    Given -> @cb = sinon.stub()
    Given -> @context =
      populateFromGrunt: sinon.stub()
      template: sinon.stub()
      prompt: sinon.stub()
      grunt:
        fail:
          fatal: sinon.stub()

    context 'no keys', ->
      Given -> @context.args = ['a', 'b']
      When -> @Builder.prototype.getDynamicValues.call @context, @cb
      Then -> expect(@cb).to.have.been.called
      And -> expect(@context.populateFromGrunt.called).to.be.false()

    context 'all keys filled by grunt', ->
      Given -> @context.args = ['{{ a }}', '{{ b }}']
      Given -> @context.populateFromGrunt.returns a: 'b', b: 'c'
      When -> @Builder.prototype.getDynamicValues.call @context, @cb
      Then -> expect(@context.populateFromGrunt).to.have.been.calledWith ['a', 'b']
      And -> expect(@context.template).to.have.been.calledWith '{{ a }}||{{ b }}',
        a: 'b'
        b: 'c'
      And -> expect(@cb).to.have.been.called
      And -> expect(@readline.createInterface.called).to.be.false()

    context 'async no error', ->
      Given -> @context.prompt.callsArgWith 1, 'answer'
      Given -> @rl =
        close: sinon.stub()
      Given -> @readline.createInterface.withArgs(
        input: process.stdin
        output: process.stdout
      ).returns @rl
      Given -> @context.args = ['{{ a }}', '{{ b }}']
      Given -> @context.populateFromGrunt.returns a: 'b', b: null
      When -> @Builder.prototype.getDynamicValues.call @context, @cb
      Then -> expect(@context.populateFromGrunt).to.have.been.calledWith ['a', 'b']
      And -> expect(@context.prompt).to.have.been.calledWith 'b', sinon.match.func
      And -> expect(@rl.close).to.have.been.called
      And -> expect(@context.template).to.have.been.calledWith '{{ a }}||{{ b }}',
        a: 'b',
        b: 'answer'
      And -> expect(@cb).to.have.been.called

    context 'async error', ->
      afterEach -> @async.reduce.restore()
      Given -> @rl =
        close: sinon.stub()
      Given -> @readline.createInterface.withArgs(
        input: process.stdin
        output: process.stdout
      ).returns @rl
      Given -> @context.args = ['{{ a }}', '{{ b }}']
      Given -> @context.populateFromGrunt.returns a: 'b', b: null
      Given -> sinon.stub @async, 'reduce'
      Given -> @async.reduce.callsArgWith 3, 'error'
      When -> @Builder.prototype.getDynamicValues.call @context, @cb
      Then -> expect(@context.populateFromGrunt).to.have.been.calledWith ['a', 'b']
      And -> expect(@rl.close).to.have.been.called
      And -> expect(@context.grunt.fail.fatal).to.have.been.calledWith 'error'
